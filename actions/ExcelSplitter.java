// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package csvsplitter.actions;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.DateUtil;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.checkerframework.checker.units.qual.Length;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;

public class ExcelSplitter extends CustomJavaAction<java.util.List<IMendixObject>>
{
	/** @deprecated use InputFile.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __InputFile;
	private final system.proxies.FileDocument InputFile;
	private final java.lang.Boolean IncludeHeader;
	private final csvsplitter.proxies.ENUM_SplitMethod SplitMethod;
	private final java.lang.Long quantity;

	public ExcelSplitter(
		IContext context,
		IMendixObject _inputFile,
		java.lang.Boolean _includeHeader,
		java.lang.String _splitMethod,
		java.lang.Long _quantity
	)
	{
		super(context);
		this.__InputFile = _inputFile;
		this.InputFile = _inputFile == null ? null : system.proxies.FileDocument.initialize(getContext(), _inputFile);
		this.IncludeHeader = _includeHeader;
		this.SplitMethod = _splitMethod == null ? null : csvsplitter.proxies.ENUM_SplitMethod.valueOf(_splitMethod);
		this.quantity = _quantity;
	}

	@java.lang.Override
	public java.util.List<IMendixObject> executeAction() throws Exception
	{
		// BEGIN USER CODE
		Core.getLogger("ExcelSplitter").info("ExcelSplitter is running");
		if (InputFile == null || quantity == null || quantity <= 0 || SplitMethod == null) {
			Core.getLogger("ExcelSplitter").error("Invalid input parameters");
			throw new IllegalArgumentException("Invalid input parameters.");
		}
		
		// Retrieve file content as an InputStream
		try (InputStream inputStream = Core.getFileDocumentContent(getContext(), InputFile.getMendixObject());
				XSSFWorkbook workbook = new XSSFWorkbook(inputStream)) {

			// Access the first sheet from the Excel file
			Sheet sheet = workbook.getSheetAt(0);
			List<String> allLines = new ArrayList<>();
			String header = null;

			// Read the file row by row
			for (int i = 0; i < sheet.getPhysicalNumberOfRows(); i++) {
			    Row row = sheet.getRow(i);
			    if (row == null) {
			        continue; // Skip null rows
			    }

			    StringBuilder rowString = new StringBuilder();
			    boolean hasNonEmptyCell = false; // Track if the row has any non-empty cell

			    for (int j = 0; j < row.getLastCellNum(); j++) {
			        Cell cell = row.getCell(j);
			        if (cell != null && !cell.toString().isBlank()) {
			            hasNonEmptyCell = true; // Found at least one non-empty cell
			            
			            // Handle all cell types and convert them to a string
			            
			            switch (cell.getCellType()) {
			                case STRING:
			                    // Directly append string cell values
			                    rowString.append(cell.getStringCellValue()).append(",");
			                    break;

			                case NUMERIC:
			                    if (DateUtil.isCellDateFormatted(cell)) {
			                        // Convert date to string using a specific format
			                        rowString.append(new SimpleDateFormat("dd/MM/yyyy").format(cell.getDateCellValue())).append(",");
			                    } else {
			                        // Convert numeric values to plain strings
			                        rowString.append(new BigDecimal(cell.getNumericCellValue()).toPlainString()).append(",");
			                    }
			                    break;

			                case BOOLEAN:
			                    // Convert boolean values to strings
			                    rowString.append(Boolean.toString(cell.getBooleanCellValue())).append(",");
			                    break;

			                case FORMULA:
			                    // Evaluate the formula result
			                    switch (cell.getCachedFormulaResultType()) {
			                        case STRING:
			                            rowString.append(cell.getStringCellValue()).append(",");
			                            break;
			                        case NUMERIC:
			                            rowString.append(new BigDecimal(cell.getNumericCellValue()).toPlainString()).append(",");
			                            break;
			                        default:
			                            rowString.append("").append(",");
			                    }
			                    break;

			                default:
			                    // Handle blank or unknown cell types
			                    rowString.append("").append(",");
			            }
			        } else {
			            rowString.append("").append(","); // Maintain structure for empty cells
			        }
			    }


			    // Skip rows without any non-empty cell
			    if (hasNonEmptyCell) {
			        // Remove trailing comma if present
			        if (rowString.length() > 0 && rowString.charAt(rowString.length() - 1) == ',') {
			            rowString.deleteCharAt(rowString.length() - 1);
			        }

			        if (i == 0) {
			            header = rowString.toString(); // First row is the header
			        } else {
			            allLines.add(rowString.toString());
			        }
			    }
			}
			Core.getLogger("ExcelSplitter").trace("allLines : "+allLines);
			int totalLines = allLines.size();
			List<IMendixObject> generatedFiles = new ArrayList<>();

			// Logic to split the file based on the selected `splitBy` method
			if (SplitMethod == csvsplitter.proxies.ENUM_SplitMethod.Thread) {
				// Split into exactly `quantity` chunks
				int linesPerThread = (int) Math.ceil((double) totalLines / quantity);
				Core.getLogger("ExcelSplitter").info("SplitMethod : "+SplitMethod+" Split to "+linesPerThread+" line per thread");
				for (int i = 0; i < quantity; i++) {
					int start = i * linesPerThread;
					int end = Math.min(start + linesPerThread, totalLines);
					if (start >= end)
						break; // No more lines to process

					List<String> chunk = allLines.subList(start, end);
					if(chunk.get(chunk.size()-1).toString().isEmpty()) {
						chunk.remove(chunk.size()-1);
					}
					IMendixObject chunkFile = createChunkFile(chunk, header, IncludeHeader, i + 1);
					generatedFiles.add(chunkFile);
				}
			} else if (SplitMethod == csvsplitter.proxies.ENUM_SplitMethod.Row) {
				// Split by row count, controlled by `quantity`
				List<String> currentChunk = new ArrayList<>();
				Core.getLogger("ExcelSplitter").info("SplitMethod : "+SplitMethod+" Split to "+quantity+" line per file");
				for (int i = 0; i < allLines.size(); i++) {
					currentChunk.add(allLines.get(i));

					if (currentChunk.size() == quantity || i == allLines.size() - 1) {
						IMendixObject chunkFile = createChunkFile(currentChunk, header, IncludeHeader,
								generatedFiles.size() + 1);
						generatedFiles.add(chunkFile);
						currentChunk = new ArrayList<>();
					}
				}
			}
			Core.getLogger("ExcelSplitter").info("ExcelSplitter is stopping");
			return generatedFiles;
		} catch (IOException e) {
			Core.getLogger("ExcelSplitter").error("Error reading Excel file: " + e.getMessage());
			throw new Exception("Error processing Excel file", e);
		}
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ExcelSplitter";
	}

	// BEGIN EXTRA CODE
	private IMendixObject createChunkFile(List<String> lines, String header, boolean includeHeader, int index)
	        throws CoreException, IOException {
	    LocalDateTime startDateTime = LocalDateTime.now();
	    IContext context = getContext();

	    // Create a new FileDocument object
	    IMendixObject fileDocument = Core.instantiate(context, "System.FileDocument");
	    fileDocument.setValue(context, "Name", "Chunk_" + index + ".xlsx");

	    // Write content to the FileDocument
	    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
	    try (Workbook workbooks = new XSSFWorkbook()) {
	        Sheet sheet = workbooks.createSheet("Sheet1");
	        int rowIndex = 0;

	        // Add header row if required
	        if (includeHeader) {
	            Row headerRow = sheet.createRow(rowIndex++);
	            String[] headerColumns = header.split(",");
	            for (int i = 0; i < headerColumns.length; i++) {
	                Cell cell = headerRow.createCell(i);
	                cell.setCellValue(headerColumns[i]);
	            }
	        }

	        // Define cell style to treat data as text
	        CellStyle textStyle = workbooks.createCellStyle();
	        textStyle.setDataFormat(workbooks.createDataFormat().getFormat("@"));

	        // Write rows to the Excel sheet
	        for (String line : lines) {
	            Row row = sheet.createRow(rowIndex++);
	            String[] columns = line.split(",");
	            for (int i = 0; i < columns.length; i++) {
	                Cell cell = row.createCell(i);
	                cell.setCellValue(columns[i]); // Set the value directly as a string
	                cell.setCellStyle(textStyle);  // Apply text style
	            }
	        }

	        // Write the workbook to the ByteArrayOutputStream
	        workbooks.write(outputStream);

	        // Save the content of the output stream to FileDocument
	        Core.storeFileDocumentContent(context, fileDocument, new ByteArrayInputStream(outputStream.toByteArray()));
	    } catch (Exception e) {
	        Core.getLogger("ExcelSplitter").error("Error creating chunk file for index " + index + ": " + e.getMessage(), e);
	        throw new IOException("Failed to create chunk file for index " + index, e);
	    }

	    // Log the time taken to create the file
	    LocalDateTime endDateTime = LocalDateTime.now();
	    long millisecondsBetween = ChronoUnit.MILLIS.between(startDateTime, endDateTime);
	    Core.getLogger("ExcelSplitter").info("Generated file: Chunk_" + index + " in " + millisecondsBetween + " ms.");

	    return fileDocument;
	}
	// END EXTRA CODE
}
